# -*- coding: utf-8 -*-
"""
/***************************************************************************
 WaterbodyJsonGeneratorDialog
                                 A QGIS plugin
 Plugin generates waterbody polygons and polylines from a Json file based on class
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by PMO
        email                : PMO
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Import packages

import json
import os
import sys
import qgis
import qgis.core
from .waterbodyClasses import Waterbody, LinearWaterbody, ArealWaterbody, Lake, Pond, Reservoir, Stream, River, Canal
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QApplication, QMainWindow, QStyle, QFileDialog, QDialog, QMessageBox, QSizePolicy
from PyQt5.QtGui import QStandardItemModel, QStandardItem,  QDoubleValidator, QIntValidator
from PyQt5.QtCore import QVariant
from PyQt5.Qt import Qt

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'WaterbodyJsonGenerator_dialog_base.ui'))


class WaterbodyJsonGeneratorDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(WaterbodyJsonGeneratorDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.jsonTB.clicked.connect(self.selectJsonFile)
        self.linesOutTB.clicked.connect(self.setOutputPolylineGeopackage)
        self.polyOutTB.clicked.connect(self.setOutputPolygonGeopackage)
        self.RunButton.clicked.connect(self.runAnalysis)

# =======================================
# GUI event handler and related functions
# =======================================

    def selectJsonFile(self):
        """open file dialog to select water bodies Json and if accepted, update GUI accordingly"""
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(self,"Select Json", "","json (*.json)")
        if fileName:
            self.jsonLE.setText(fileName)

    def setOutputPolylineGeopackage(self):
        """open file dialog to output query results geopackage and if accepted, update GUI accordingly"""
        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Select geopackage", "","geopackage (*.gpkg)")
        if fileName:
            self.linesOutLE.setText(fileName)

    def setOutputPolygonGeopackage(self):
        """open file dialog to output query results geopackage and if accepted, update GUI accordingly"""
        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Select geopackage", "","geopackage (*.gpkg)")
        if fileName:
            self.polyOutLE.setText(fileName)

    def runAnalysis(self):
        """runs analysis for creating waterbodies"""
        filename =self.jsonLE.text()
        streamOutfile = self.linesOutLE.text()
        lakeOutfile = self.polyOutLE.text()

        #Open json file
        with open(filename, encoding = "utf8") as file:
            data = json.load(file)

        nodesDict = {}  # create empty dictionary for the node elements
        waysDict = {}   # create empty dictionary for the way elements

        for element in data['elements']:            # go through all elements in input data
            if element['type'] == 'node':           # check if element is an OSM node
                nodesDict[element['id']] = element  # place element in nodes dictionary using its ID as the key
            elif element['type'] == 'way':          # check if element is an OSM way
                waysDict[element['id']] = element   # place element in ways dictionary using its ID as the key


        #Create stream and lake vector layers and establish associated data providers
        streamLayer = qgis.core.QgsVectorLayer('LineString?crs=EPSG:4326&field=NAME:string(50)&field=TYPE:string(50)&field=LENGTH:Double','scratchStream','memory')
        streamProv = streamLayer.dataProvider()
        lakeLayer = qgis.core.QgsVectorLayer('Polygon?crs=EPSG:4326&field=NAME:string(50)&field=TYPE:string(50)&field=AREA:Double','scratchLake','memory')
        lakeProv = lakeLayer.dataProvider()

        #Create class list
        classes = [Stream, Canal, River, Lake, Pond, Reservoir]
        #loop through both ways and classes
        for way in waysDict:
            for cl in classes:
                #call class method fromOSMWay stored in waterbodyClasses python file
                result = cl.fromOSMWay(waysDict[way], nodesDict)
                # if a result exists, call the toQgsFeature method stored in waterbodyClasses python file
                if result:
                    feat = result.toQgsFeature()
                    #check class and output feature to appropriate data provider
                    if cl == Stream or cl == Canal or cl == River:
                        streamProv.addFeatures([feat])
                    else:
                        lakeProv.addFeatures([feat])
                # if no result, print out statement and proceed through loop
                else:
                    print('return value is None -> no object of class ' + str(cl) + ' has been created')
        # output data providers as vector files to designated location
        qgis.core.QgsVectorFileWriter.writeAsVectorFormat(streamLayer, streamOutfile, "utf-8", streamLayer.crs())
        qgis.core.QgsVectorFileWriter.writeAsVectorFormat(lakeLayer, lakeOutfile, "utf-8", lakeLayer.crs())




